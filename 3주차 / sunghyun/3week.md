# 12. 함수

## 12.1 함수란?

- 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 **실행 단위**로 정의한 것

## 12.2 함수를 사용하는 이유

- 반복되는 코드의 재사용을 위해 사용함

## 12.3 함수 리터럴

```js
// 변수에 함수 리터럴을 할당
let f = function add(x, y) {
  return x * y;
};
```

- 자바스크립트의 함수는 객체 타입의 값임
- 객체를 객체 리터럴로 생성하는 것처럼 함수도 리터럴로 생성할 수 있음
- 사람이 이해할 수 있도록 표기하는 것이 리터럴 방식이었음
- 함수 리터럴 또한 평가되어 값을 생성하는데 이 값은 객체
- **즉, 함수는 객체다.**

**함수 리터럴의 구성 요소**

- 함수 이름
  - 함수 이름은 식별자, 따라서 네이밍 규칙을 준수
  - **함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자**
  - 함수 이름은 생략 가능 (익명 함수, 기명 함수)
- 매개변수
  - 함수를 호출할 때 지정한 인수는 순서대로 할당
  - **매개변수는 함수 몸체 내에서 변수와 동일하게 취급**
  - 변수와 마찬가지로 식별자 네이밍 규칙을 준수
- 함수 몸체

## 12.4 함수 정의

- 함수 선언문
- 함수 표현식
- Function 생성자 함수
- 화살표 함수(ES6)

### 12.4.1 함수 선언문

```js
function add(x, y) {
  return x * y;
}
```

- 함수 리터럴과 형태가 동일함
- 단, 함수 선언문은 함수 이름을 생략할 수 없음
- 자바스크립트 엔진은 암묵적으로 함수 선언문을 **함수 표현식**으로 변환해 함수 객체를 생성함

### 12.4.2 함수 표현식

```js
let add = function add(x, y) {
  return x * y;
};
```

- 함수를 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 정의 방식
- 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적임
  - 단, 재귀적으로 사용하거나 디버깅을 할 때 기명으로 표기하기도 함

### 12.4.3 함수 생성 시점과 함수 호이스팅

- 함수 선언문으로 정의한 함수는 런타임 이전에 함수 객체가 먼저 생성됨
- 따라서 선언문 이전에 함수를 미리 참조하고 호출할 수 있음
- 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 특징을 **함수 호이스팅**이라고 함

cf. 함수 호이스팅과 변수 호이스팅

- `var` 키워드를 사용한 `변수 선언문`과 `함수 선언문`은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일함
- `var` 키워드를 사용한 변수 선언문 이전에 변수를 참조하면 `undefined`
- 반면에 `함수 선언문`으로 정의한 함수를 함수 선언문 이전에 호출이 가능함
- 함수 선언문으로 작성한 함수는 함수 호이스팅이 발생하는 것
- 함수 표현식으로 함수를 정의하면 변수 호이스팅이 발생하는 것
  - 따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 호출해야 함
- 더글라스 크락포드는 함수 선언문 대신 함수 표현식을 사용할 것을 권장한다고 함

### 12.4.4 Function 생성자 함수

```js
let add = new Function("x", "y", "return x+y");
console.log(add(2, 5)()); // 7
```

- 빌트인 Function 생성자 함수를 통해 함수를 생성하는 방식
- 해당 방식으로 생성한 함수는 클로저를 생성하지 않는 등
- 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다고 함

(해당 부분은 책 후반부에서 자세히 다룰 예정)

### 12.4.5 화살표 함수

```js
const add = (x, y) => x * y;
console.log(add(2, 5)()); // 10
```

- 화살표 함수는 항상 익명으로 정의함
- 함수 선언문 또는 함수 표현식을 완전히 대체하기 위해 고안된 것은 아님
- 표현만 간략한 것이 아니라 내부 동작 또한 간략화되어 있음
- `this` 바인딩 방식이 다르고 `prototype` 프로퍼티가 없으며 `arguments` 객체를 생성하지 않음

(해당 부분은 책 후반부에서 자세히 다룰 예정)

## 12.5 함수 호출

- 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮김

### 12.5.1 매개변수와 인수

- 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급
- 함수가 호출되면 함수 내부에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 `undefined`로 초기화된 이후 인수가 순서대로 할당됨
  - **[Q. 질문]** 매개변수가 암묵적으로 생성되는 거면 이 매개변수는 함수 식별자 내부에서 또 다른 식별자가 되는 걸까요? 예를 들면 매개변수를 x와 y로 지정한다고 했을 때 x와 y도 식별자가 되는 것인지?
- 매개변수는 함수 내부에서만 참조할 수 있음
- 즉, 매개변수의 스코프는 함수 내부
- 인수가 부족해서 할당하지 않는 매개변수의 값은 `undefined`
- 매개변수보다 초과된 인수는 무시됨
  - 모든 인수는 암묵적으로 `arguments` 객체의 프로퍼티로 보관됨 (초과된 인수 포함)

### 12.5.2 인수 확인

- 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않음
- 자바스크립트는 동적 타입의 언어임
- 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없음
- ES6에서 도입된 매개변수 `기본값`을 사용하면 함수 내에서 인수 체크 및 초기화를 간소화할 수 있음
- 이로 인해 발생하는 문제를 **타입스크립트**를 도입해서 사전에 방지할 수 있음
- 반환문(`return` 뒤의 문)은 생략할 수 있지만 `undefined`를 반환함
- 반환문은 함수 몸체 내부에서만 사용 가능

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 매개변수에 인수를 할당할 때
- 원시 타입의 인수는 그 값을 변경(재할당을 통해 값이 변경)해도 원본이 훼손되지 않음
- 객체 타입의 인수는 그 값을 바꾸면 원본도 변경됨
  - 이처럼 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워짐
  - **코드 복잡성 증가**, **가독성을 해치는 원인**
    - 객체의 변경을 추적하려면 `옵저버 패턴`을 통할 수 있음
    - `불변 객체`를 만들어서 외부 상태 변경을 막을 수 있음 (`깊은 복사`)

외부 상태를 변경하지 않고 외부 상태에 의존하지 않아도 되는 함수를 **순수 함수**라고 한다. 순수 함수를 통해 부수 효과를 최대한 억제하여 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 **함수형 프로그래밍**이라고 한다.

- 유인동님의 함수형 프로그래밍 강의를 들어야겠음

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수

```js
// 익명 즉시 실행 함수
(function () {
  let a = 3;
  let b = 5;
  return a * b;
})();
// 기명 즉시 실행 함수
(function foo() {
  let a = 3;
  let b = 5;
  return a * b;
})(); // ReferenceError: foo is not defined
```

- 함수 정의와 동시에 즉시 호출되는 함수
- 즉시 실행 함수는 단 한 번만 호출되며 다시 호출할 수 없음
- 즉시 실행 함수는 일반적으로 `익명 함수`를 사용하며
- `기명 함수`를 사용할 수 있지만 다시 호출할 수 없음
- **즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지할 수 있음**

### 12.7.2 재귀 함수

```js
// 팩토리얼
function factorial(n) {
  // 탈출 조건 : n이 1 이하일 때 재귀 호출을 멈춤
  if (n <= 1) return 1;
  // 재귀 호출
  return n * factorial(n - 1);
}
console.log(factorial(0)); // 0! = 1
console.log(factorial(1)); // 1! = 1
console.log(factorial(2)); // 2! = 2 * 1 = 2
console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120
```

- 함수가 자기 자신을 호출하는 것을 재귀 호출이라고 함
- 재귀 함수는 자기 자신을 호출하는 함수를 말함
- 함수 이름은 물론 함수를 가리키는 식별자로도 자기 자신을 호출할 수 있음
  - 단, 함수 외부에서 호출할 때는 반드시 함수를 가리키는 식별자로 호출
- 재귀 함수는 반드시 **탈출 조건**을 만들어서 사용해야 함

### 12.7.3 중첩 함수

````js
function outer(){
  let x = 1;
  // 중첩 함수
  function inner(){
    let y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x+y) // 3;
  }
  inner();
}
outer();
```
````

### 12.7.4 콜백 함수

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 매개변수를 통해 콜백 함수를 전발 받은 함수는 고차 함수

```js
// 콜백 함수를 익명으로 전달한다.
// 익명 함수는 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다.
repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 1 3
```

- 함수 내부에서만 전달한 콜백 함수가 사용되면 익명 함수로 사용해도 되지만
- 콜백 함수를 전달받는 함수(고차 함수)가 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 **함수 자체**를 전달해서 사용
- 콜백 함수는 함수형 프로그래밍 뿐만 아니라 비동기의 꽃이라고 할 수 있음

### 12.7.5 순수 함수와 비순수 함수

- 순수 함수 : 어떤 외부 상태에 의존하지도 않고 변경하지도 않는 순수 함수
- 비순수 함수 : 그와 반대

함수형 프로그래밍은 외부 상태 변경을 최소화하고 로직 내에 존재하는 조건문과 반복분을 제거해서 복잡성을 해결하며 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 함

# 13. 스코프

## 13.1 스코프란

- 식별자를 검색할 때 사용하는 규칙 즉, 식별자의 유효 범위
- 컴퓨터의 `폴더`를 생각하면 이해하기 쉬움

## 13.2 스코프의 종류

- 전역 스코프(Global scope)
- 지역 스코프(Local scope)

## 13.3 스코프 체인

- 스코프가 함수의 중첩에 의해 계층적인 구조를 갖는데
- 이는 렉시컬 환경의 스코프 체인을 통해 가능한 것임
- 상위 스코프를 하위 스코프에서 참조할 수 있지만 하위 스코프를 상위에서 참조하는 게 불가능한 이유 또한 스코프 체인은 **계층적**이기 때문

## 13.4 함수 레벨 스코프

- 함수에 의해서만 지역 스코프가 생성되다는 의미
  - `var` 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정
  - 이러한 특성을 함수 레벨 스코프라고 함

## 13.5 렉시컬 스코프

- **동적 스코프** : 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정
- **렉시컬 스코프(정적 스코프)** : 함수를 어디에 정의했는지에 따라 상위 스코프를 결정
- 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않음
- 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프

# 14. 전역 변수의 문제점

- 전역 변수는 스코프 체인 상에서 종점에 존재함
- 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말함
- 호이스팅은 스코프를 단위로 동작함
- `var` 키워드로 선언한 전역 변수는 전역 객체(`window`)의 프로퍼티가 됨
  - 즉, `var` 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치
  - 때문에 전역 변수 사용을 최대한 지양해야 함

## 14.3 전역 변수의 사용을 억제하는 방법

일반적으로 지역 변수를 지향하면 됨

- 즉시 실행 함수
- 네임스페이스 객체
- 모듈 패턴
  - 클래스를 모방해서 관련이 있는 변수와 함수를 모아 `즉시 실행 함수`로 감싸서 하나의 모듈을 만듬 / 캡슐화까지 구현할 수 있다는 장점이 있음
  - 캡슐화는 프로퍼티와 메서드를 하나로 묶는 것을 말함
- ES6 모듈
  - 파일 자체의 독자적인 모듈 스코프를 제공함
  - ES6에서 제공하는 모듈을 사용하면 전역 변수를 사용할 수 없음
  - `var` 키워드로 선언한 변수는 전역 변수가 아니며 `window` 객체의 프로퍼티도 아님
  - `script` 태그에 `type="module"` 속성을 추가하면 로드된 파일은 모둘로 동작하며 파일의 확장자는 `mjs`
  - 브라우저의 ES6 모듈을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 `Webpack` 등의 모듈 번들러를 사용함

# 15. let, const 키워드와 블록 레벨 스코프

- `var` 키워드
  - 함수 레벨 스코프
  - 변수 중복 선언 허용
  - 변수 호이스팅
    - 변수 선언문 이전에 참조할 수 있음
    - 단, 할당문 이전에 변수를 참조하면 `undefined`를 반환
    - `선언 단계`와 `초기화 단계`가 한번에 진행됨
      - **선언 단계**에서(실행 컨텍스트의 렉시컬 환경)에 변수 식별자를 등록해서 자바스크립트 엔진에 변수의 존재를 알림
      - **초기화 단계** `undefined`로 변수를 초기화함
      - 선언문 이전에 변수에 접근하면 따라서 `undefined`가 반환되는 것이고 이후에 변수 할당문에 도달하면 값이 할당됨
- `let`, `const` 키워드

  - 블록 레벨 스코프
  - 변수 중복 선언 금지
  - 변수 호이스팅
    - `선언 단계`와 `초기화 단계`가 분리되어 진행
    - 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 `변수 선언문`에 도달했을 때 실행됨
    - 만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 `참조 에러(ReferenceError)`가 발생함
    - `let`, `const` 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없는데 이 구간을 `일시적 사각지대(Temporal Dead Zond:TDZ)`라고 부름
    - 호이스팅이 되지만 발생하지 않는 것처럼 동작하는 이유가 이 때문임

- const 키워드
  ```js
  const foo = 1;
  ```
  - const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야 함
  - const 키워드는 상수를 표현하는 데 사용함 (상수는 재할당이 불가능함)
  - const 키워드로 선언한 원시 값은 값을 변경할 수 없지만 객체를 할당한 경우 값을 변경할 수 있음

# var vs let vs const

- 변수 선언에는 기본적으로 `const`를 사용하고 `let`은 재할당이 필요한 경우에만 사용
- 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시 값과 객체에는 `const` 키워드를 사용
