## 8장 제어문
제어문(Control flow statement)은 조건에 따라 코드 블록을 실행, 반복 실행 할 때 사용된다. `if(true)`

블록문(block statement)는 0개 이상의 문을 중괄호로 묶은 것이다. `{ f() }`

```js
// 아래와 같이 케이스 문 실행 후 탈출하지 않고 진행하는 것을 fall through라 부른다.
x=0
switch (5):
  case 5:
    x+=5
  default:
    x+=1
// x=6 
```

break 문

break문은 속해있는 반복문을 탈출한다.
```js
cnt=0
for (let i=0;i<5;i+=1) {
  for (let j=0;j<5;j+=1) {
    cnt+=1
    break
  }
}

//cnt = 5
```
## 9장 타입 변환과 단축 평가
# 9.2 암묵적 타입 변환
## 9.2.1문자열 타입으로 변환
```js
[10, 20] + '' // "10, 20"
(function(){}) + '' // "function(){}"
Array + '' // "function Array() { [native code] }
```
## 9.2.2 숫자 타입으로 변환
```js
// + 단항 연산자가 아니면 문자열보다 숫자가 우세
1 - '1' // 0
1 * '10' // 10
1 / 'one' // NaN
'0' * 1 // 0
'10.53' * 1 // 10.53
true * 1 // 1
```

## 9.2.3 불리언 타입으로 변환
```js
// Truty
true
'0'
{}
[]
// Falsy
false
undefined
null
0
-0
NaN
''
```
# 9.3 명시적 타입 변환
```js
// 숫자 => 문자열
String(NaN) // 'NaN'
(1).toString() // '1'

// undefined => 불리언
!!undefined // !undefined 일 때 undefined는 falsy이므로 true로 변경되고 다음 부정연산자일 때 false가 됨
```

# 9.4 단축 평가
```js
'test' && 'test2' // 'test2'
'test' || 'tet2' // 'test'
```

# 9.4.3 null 병합 연산자 - "??"
## 탄생 배경
논리 연산자 "||" 사용한 단축 평가의 경우 좌항의 피연산자가 falsy 일경우 우항의 피연산자를 반환한다.
이 때에 0, ''가 들어올 경우 예상치 못한 상황이 발생할 수 있다.
## 설명
좌항의 피연산자가 null 또는 undefined 일 때만 우항의 피연산자를 반환한다.
```js
var foo = '' ?? 'string' // '' 반환
```

# 10장 객체 리터럴
## 10.1 객체란?
원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.

프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다.

## 10.2 객체 리터럴에 의한 객체 생성
인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체
클래스: 인스턴스를 생성하기 위한 템플릿의 역할

## 10.3 프로퍼티
프로퍼티는 키와 값으로 구성된다.

프로퍼티 키는 문자열이어야 한다. 단, 식별자 네이밍 규칙을 준수하는 이름과 변수는 가능하다.
```js
var abc = 'abc'
var person = {
  // 문자열 키
  'test': 1, 
  // 식별자 네이밍 규칙을 준수했기 때문에 "", '' 없이 사용 가능
  test2: 2,
  // 네이밍 규칙 준수하지 않았지만, 문자열이기 때문에 가능
  'te-st': 3,
  // 변수
  abc: 2,
  // 빈 문자열도 가능하다.
  '': 'test' 
}
```

## 10.5 프로퍼티 접근
프로퍼티에 접근하는 방법은 두 가지이다.
1. 마침표 프로터피 접근 연산자(.) 
2. 대괄호 프로퍼티 접근 연산자([])

주의: 객체에 존재하지 않는 프로퍼티 접근시 에러가 아닌 undefined가 반환된다.

## 10.7 프로퍼티 동적 생성
typescript에서는 아래와 같은 방법으로 동적 생성한다.
```ts
const person: {[key:string]: any} = {
    id: 1234
}
person["test"] = 3
```

## 10.8 프로퍼티 삭제
delete 연산자로 객체의 프로퍼티를 삭제할 수 있다. 단, typescript에서는 쓰지 않는 것이 좋다.(4.0 이상해서는 에러 발생)
```ts
var person = {
  name: 'Jack'
}
delete person.name
console.log(person.name.length) // TypeError: Cannot read property 'length' of undefined

// 위보다는 아래의 구조분해할당으로 프로퍼티를 제거한다.
const person = {
    id: 'test'
}
const { id, ...rest} = person
console.log(rest) // {}
```

# 11장 원시 값과 객체의 비교
데이터 타입을 원시 값과 객체 타입으로 구분하는 이유

1. 원시 타입: 변경 불가능한 값

원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다.

원시 값을 다른 변수에 할당하면 원시 값이 복사되어 전달된다. - pass by value

2. 객체 타입: 변경 가능한 값

객체를 변수에 할당하면 변수에는 참조 값이 저장된다.

객체를 다른 변수에 할당하면 참조 값이 복사되어 전달된다. - pass by reference

성능 면에서는 이론적으로 클래스 기반 프로그래밍이 더 좋다. 왜냐하면 인스턴스가 할당된 이후에 프로퍼티를 추가 할 수 없기 때문이다.

자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다.

JS에서는 원시, 객체 변수를 생성하면 메모리에 새로운 공간이 할당되고 그 곳에 값이 저장된다.

그렇기 때문에 객체 변수 A를 다른 변수 B에 할당하면 B의 메모리 공간에 A의 주소값이 저장된다. 반면 JAVA와 같은 언어는 A,B 같은 메모리 공간을 갖는다.  - call by sharing

![callBySharing](callbysharing.jpg)

python의 경우 A, B가 서로 같은 메모리 주소를 쓰고있다가 재할당이 이뤄지면 비로소 서로 다른 메모리 주소 공간이 만들어진다.




